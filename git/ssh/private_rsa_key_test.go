package ssh_test

import (
	"crypto/rand"
	"crypto/rsa"
	"io/ioutil"
	"os"
	"testing"

	"github.com/andrewslotin/doppelganger/git/ssh"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	crypto_ssh "golang.org/x/crypto/ssh"
)

func TestReadPrivateRSAKey_ValidFile(t *testing.T) {
	// Read a corresponding public key generated by ssh-keygen
	pubkey, err := readTestPublicSSHKey("./testdata/test_key_rsa.pub")
	require.NoError(t, err)

	pkey, err := ssh.ReadPrivateRSAKey("./testdata/test_key_rsa")
	require.NoError(t, err)
	require.NoError(t, pkey.Validate())

	ok, err := testValidRSAKeyPair(pkey, pubkey)
	require.NoError(t, err)
	assert.True(t, ok)
}

func TestReadPrivateRSAKey_NoFile(t *testing.T) {
	path, cleanup, err := mkTempFile()
	require.NoError(t, err)
	cleanup()

	_, err = ssh.ReadPrivateRSAKey(path)
	assert.Error(t, err)
}

func TestReadPrivateRSAKey_EmptyFile(t *testing.T) {
	path, cleanup, err := mkTempFile()
	require.NoError(t, err)
	defer cleanup()

	_, err = ssh.ReadPrivateRSAKey(path)
	assert.Error(t, err)
}

func TestReadPrivateRSAKey_NotPEMFile(t *testing.T) {
	path, cleanup, err := mkTempFile()
	require.NoError(t, err)
	defer cleanup()

	fd, err := os.OpenFile(path, os.O_WRONLY|os.O_TRUNC, 0644)
	require.NoError(t, err)
	fd.Write([]byte("This is not a private key file!\n"))
	fd.Close()

	_, err = ssh.ReadPrivateRSAKey(path)
	assert.Error(t, err)
}

func TestReadPrivateRSAKey_NotRSAKey(t *testing.T) {
	_, err := ssh.ReadPrivateRSAKey("./testdata/test_key_dsa")
	assert.Error(t, err)
}

func TestCreatePrivateRSAKey_GeneratesValidKey(t *testing.T) {
	path, cleanup, err := mkTempFile()
	require.NoError(t, err)
	defer cleanup()

	pkey, err := ssh.CreatePrivateRSAKey(path)
	require.NoError(t, err)
	require.NoError(t, pkey.Validate())
}

func TestCreatePrivateRSAKey_StoresReadableKey(t *testing.T) {
	path, cleanup, err := mkTempFile()
	require.NoError(t, err)
	defer cleanup()

	generatedPkey, err := ssh.CreatePrivateRSAKey(path)
	require.NoError(t, err)

	decodedPkey, err := ssh.ReadPrivateRSAKey(path)
	require.NoError(t, err)

	pubkey, err := crypto_ssh.NewPublicKey(&generatedPkey.PublicKey)
	require.NoError(t, err)

	ok, err := testValidRSAKeyPair(decodedPkey, pubkey)
	require.NoError(t, err)
	assert.True(t, ok)
}

func readTestPublicSSHKey(path string) (crypto_ssh.PublicKey, error) {
	data, err := ioutil.ReadFile(path)
	if err != nil {
		return nil, err
	}

	pubkey, _, _, _, err := crypto_ssh.ParseAuthorizedKey(data)
	return pubkey, err
}

func mkTempFile() (path string, cleanupFn func(), err error) {
	fd, err := ioutil.TempFile(os.TempDir(), "test_pkey")
	if err != nil {
		return "", nil, err
	}

	return fd.Name(), func() { os.Remove(fd.Name()) }, fd.Close()
}

// Sign a message given private key and check that the signature can be verified with provided public key.
func testValidRSAKeyPair(pkey *rsa.PrivateKey, pubkey crypto_ssh.PublicKey) (bool, error) {
	msg := []byte("Test message")

	signer, err := crypto_ssh.NewSignerFromKey(pkey)
	if err != nil {
		return false, err
	}

	signature, err := signer.Sign(rand.Reader, msg)
	if err != nil {
		return false, err
	}

	return pubkey.Verify(msg, signature) == nil, nil
}
